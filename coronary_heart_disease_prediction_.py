# -*- coding: utf-8 -*-
"""Coronary Heart Disease Prediction .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mSJ5Mwh7HLQMmpwLnTArqMLzc3HKAK6o

Importing Libraries and Packages
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline
import seaborn as sns
from sklearn.linear_model import LogisticRegression
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.svm import SVC
from sklearn.neural_network import MLPClassifier
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.model_selection import RandomizedSearchCV, GridSearchCV
from sklearn.metrics import precision_score, recall_score, f1_score, roc_auc_score, roc_curve
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()

"""Dataset Upload"""

df = pd.read_csv('heart.csv')

"""Dataset Analysis"""

df.shape

df.head(6)

df.info()

#Checking for duplicates in the dataset
duplicates = df.duplicated()
duplicate_rows = df[df.duplicated()]
duplicate_rows.shape

#Checking for missing values
df.isnull().sum().sort_values(ascending = False)

"""Dataset Visualisation"""

df['HeartDisease'].value_counts()

df['HeartDisease'].value_counts().plot(kind = 'bar', color = ['red','indigo'])

df.describe()

df['Age'].plot.hist(bins = 77)
plt.xlabel("Age")
plt.ylabel("Frequency")
plt.title('Age Distribution')

sns.displot(data = df, hue= 'HeartDisease', x = 'Age')
plt.xticks(rotation=90)

df['age_group'] = pd.cut(df['Age'], bins=[30, 40, 50, 60, 70, 80], right=False)
age_heart_failure_counts = df.groupby('age_group')['HeartDisease'].sum().reset_index()

plt.figure(figsize=(10, 6))
sns.barplot(data=age_heart_failure_counts, x='age_group', y='HeartDisease', palette='coolwarm')
plt.title('Heart Failure Counts by Age Group')
plt.xlabel('Age Group')
plt.ylabel('Number of Heart Failures')
plt.show()

df['age_group'] = pd.cut(df['Age'], bins=[25, 35, 45, 55, 65, 75, 85], right=False)
sns.countplot(data = df, hue= 'HeartDisease', x = 'age_group')
plt.xticks(rotation=90)

sns.countplot(x ='ChestPainType', data = df, palette = 'cool')
plt.title('Chest Pain Type')

sns.countplot(data = df, hue= 'HeartDisease', x = 'ChestPainType')

sns.countplot(data = df, hue= 'HeartDisease', x = 'ST_Slope')

sns.countplot(x='ST_Slope', data = df, palette ='dark')
plt.title('Distribution of ST Slope')

sns.countplot(x='ExerciseAngina', data = df, palette = 'cool')
plt.title('Distribution of Exercise Angina')

sns.countplot(data = df, hue= 'HeartDisease', x = 'ExerciseAngina')

df['Cholesterol'].plot.hist(bins = 41)
plt.xlabel("Cholesterol")
plt.ylabel("Frequency")
plt.title('Cholesterol Distribution')

sns.countplot(x='Sex', data = df, palette = 'cool')
plt.title('Sex Frequency Distrubtion')

df['RestingBP'].plot.hist(bins = 80, color = "red")
plt.xlabel("RestingBP")
plt.ylabel("Frequency")
plt.title('RestingBP Distribution')

sns.countplot(x='FastingBS', data = df, palette = 'cool')
plt.xlabel("FastingBS")
plt.ylabel("Frequency")
plt.title('FastingBS Distribution')

df['MaxHR'].plot.hist(bins = 26)
plt.xlabel("MaxHR")
plt.ylabel("Frequency")
plt.title('MaxHR Distribution')

df['Oldpeak'].plot.hist(bins = 60, color = 'orange')
plt.xlabel("Oldpeak")
plt.ylabel("Frequency")
plt.title('Oldpeak Distribution')

sns.countplot(x='RestingECG', data = df, palette = 'cool')
plt.title('Distribution of Resting ECG')

sns.countplot(x='RestingECG', data = df, hue = 'HeartDisease')
plt.title('Resting ECG Result in Comparison with Heart Disease')

sns.pairplot(data = df, hue = 'HeartDisease')

column=['Age','RestingBP','Cholesterol','MaxHR','Oldpeak']
plt.figure(figsize=(20,7))
plt.title("Numerical Data with box plot")
for i,category in enumerate(column):
  plt.subplot(2,3,i+1)
  sns.boxplot(data=df[category],color='cyan',orient="h")
  plt.title(category)
  plt.tight_layout()
plt.show()

sns.boxplot(data = df, x ='HeartDisease', y = 'Cholesterol')

sns.boxplot(data = df, x ='HeartDisease', y ="MaxHR")

sns.boxplot(data = df, x ='HeartDisease', y = 'RestingBP')

# Converting Categorical Data to Numerical
df.Sex.replace({'M':1,'F':0}, inplace = True)
# ChestPainType
df.ChestPainType.replace({'TA':0, 'ATA':1, 'NAP':2, 'ASY':3 }, inplace = True) # RestingECG
df.RestingECG.replace({'Normal':0, 'ST':1, 'LVH':2}, inplace = True) # ExerciseAngina
df.ExerciseAngina.replace({'N':0, 'Y':1}, inplace = True)
# ST_Slope
df.ST_Slope.replace({'Up':0, 'Flat':1, 'Down':2}, inplace = True)

df = df.drop('age_group', axis =1)

df.head()

corr=df.corr()
plt.figure(figsize=(12,7))
sns.heatmap(corr,annot=True)

"""FEATURE ENGINEERING

From the EDA conducted, I observed that, the attributes – RestingBP and Cholesterol – have some instances with zero values which are
inconsistent with the attribute values. These are handled as missing values and replaced with the Mean values. While the outliers observed in the following features - Resting BP, Cholesterol, and Old Peak -  were removed.
"""

df[df['Cholesterol']==0]

df['Cholesterol'].replace(0, int(df['Cholesterol'].mean()), inplace=True)

df[df['Cholesterol']==0]

df[df['RestingBP']==0]

df['RestingBP'].replace(0, int(df['RestingBP'].mean()), inplace=True)

df[df['RestingBP']==0]

#Removing Resting BP outliers
Q1 = df['RestingBP'].quantile(0.25)
Q3 = df['RestingBP'].quantile(0.75)

# Calculate IQR
IQR = Q3 - Q1

# Define a range for outliers
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Remove outliers
df_cleaned = df[(df['RestingBP'] >= lower_bound) & (df['RestingBP'] <= upper_bound)]
df_cleaned.shape

fig, ((ax1, ax2)) = plt.subplots(1, 2)
ax1.boxplot(df['RestingBP'], patch_artist=True, vert = False)
ax1.set_title('Outliers')
ax2.boxplot(df_cleaned['RestingBP'], patch_artist=True, vert = False)
ax2.set_title('Removed Outliers')
plt.show()

#Removing Cholesterol outliers
Q1 = df_cleaned['Cholesterol'].quantile(0.25)
Q3 = df_cleaned['Cholesterol'].quantile(0.75)

# Calculate IQR
IQR = Q3 - Q1

# Define a range for outliers
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Remove outliers
df_clean = df_cleaned[(df_cleaned['Cholesterol'] >= lower_bound) & (df_cleaned['Cholesterol'] <= upper_bound)]
df_clean.shape

fig, ((ax1, ax2)) = plt.subplots(1, 2, figsize=(6, 4))
ax1.boxplot(df['Cholesterol'], patch_artist=True, vert = False)
ax1.set_title('Outliers')
ax2.boxplot(df_clean['Cholesterol'], patch_artist=True, vert = False)
ax2.set_title('Removed Outliers')
plt.show()

#Removing Old Peak outliers
Q1 = df_clean['Oldpeak'].quantile(0.25)
Q3 = df_clean['Oldpeak'].quantile(0.75)

# Calculate IQR
IQR = Q3 - Q1

# Define a range for outliers
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# Remove outliers
df_new = df_clean[(df_clean['Oldpeak'] >= lower_bound) & (df_clean['Oldpeak'] <= upper_bound)]
df_new.shape

fig, ((ax1, ax2)) = plt.subplots(1, 2, figsize=(6, 4))
ax1.boxplot(df['Oldpeak'], patch_artist=True, vert = False)
ax1.set_title('Outliers')
ax2.boxplot(df_new['Oldpeak'], patch_artist=True, vert = False)
ax2.set_title('Removed Outliers')
plt.show()

df_new.head()

numerical_cols = ['RestingBP', 'Cholesterol', 'MaxHR', 'Oldpeak']
df1 = scaler.fit_transform(df_new[numerical_cols])
df1 = pd.DataFrame(df1, columns=numerical_cols)
df1.head()

"""Modelling"""

# Train Test Split (70:30)
X = df_new.drop('HeartDisease', axis=1)
y = df_new['HeartDisease']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.30, random_state = 47)

# Defining a function to plot the Receiver Operating Characteristic (ROC) curve
def plot_roc_curve(y_true, y_scores):
    # Calculate the false positive rate (FPR) and true positive rate (TPR)
    fpr, tpr, _ = roc_curve(y_true, y_scores)

    # Calculate the area under the ROC curve (AUC)
    auc = roc_auc_score(y_true, y_scores)

    # Plot the ROC curve
    plt.figure()
    plt.plot(fpr, tpr, label='ROC curve (AUC = {:.2f})'.format(auc))
    #plt.plot([0, 1], [0, 1], 'k--')  # Diagonal line (random classifier)
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.05])
    plt.xlabel('False Positive Rate (FPR)')
    plt.ylabel('True Positive Rate (TPR)')
    plt.title('Receiver Operating Characteristic (ROC) Curve')
    plt.legend(loc='lower right')
    plt.show()

lr = LogisticRegression()
lr.fit(X_train, y_train)
predictions = lr.predict(X_test)
print(confusion_matrix(y_test, predictions))
print(classification_report(y_test, predictions))
print("ROC_AUC Score : ",'{0:.2%}'.format(roc_auc_score(y_test,predictions)))
plot_roc_curve(y_test, predictions)

Rf = RandomForestClassifier(max_depth=6, n_estimators=500, min_samples_split=4)
Rf.fit(X_train, y_train)
predictions = Rf.predict(X_test)
print(confusion_matrix(y_test, predictions))
print(classification_report(y_test, predictions))
print("ROC_AUC Score : ",'{0:.2%}'.format(roc_auc_score(y_test,predictions)))
plot_roc_curve(y_test, predictions)

knn = KNeighborsClassifier(n_neighbors=12)
knn.fit(X_train, y_train)
predictions = knn.predict(X_test)
print(confusion_matrix(y_test, predictions))
print(classification_report(y_test, predictions))
print("ROC_AUC Score : ",'{0:.2%}'.format(roc_auc_score(y_test,predictions)))
plot_roc_curve(y_test, predictions)

